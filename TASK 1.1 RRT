import cv2
import numpy as np
import math
import time

begin = time.time()
prob=np.random.randint(20,31)
img=np.full((20,20),255).astype(np.uint8)
count=0
while(count<4*prob):
    i=np.random.randint(0,20)
    j=np.random.randint(0,20)
    if(img[i,j]!=0):    #checking for repitition
        count+=1
        img[i,j]=0

img=cv2.resize(src=img,dsize=(40,40),interpolation=cv2.INTER_AREA)
n=0
pos1 = [] #stores row number for starting and ending point
pos2 = [] #stores column number for starting and ending point
while ( n < 2 ): #for generating random starting and ending point
    i=np.random.randint(0,40)
    j=np.random.randint(0,40)
    if (img[i,j]==255):    #checking for a white pixel
        pos1.append(i)
        pos2.append(j)
        n+=1
        img[i,j]=127
n, m = img.shape
a = pos1[0]
b = pos2[0]
c = pos1[1]
d = pos2[1]
print(a,b)
print(c,d)
# start : a,b
# end : c,d
cv2.namedWindow('Image', cv2.WINDOW_NORMAL)
cv2.imshow('Image', img)
img[a][b] = 255
img[c][d] = 255

c1=c
d1=d
tr = np.full((n,m),0)
img1=np.full((n,m,3),0)
for i in range(n):
    for j in range(m):
        if img[i,j]==255:
            img1[i][j][0]=255
            img1[i][j][1] = 255
            img1[i][j][2] = 255
tr[a][b] = 200

def dist(p,q,r,s):
    k1 = (p-r)*(p-r)
    k2 = (q - s) * (q - s)
    u = math.sqrt(k1+k2)
    return u

cv2.namedWindow('tree', cv2.WINDOW_NORMAL)
while True :
    i1 = np.random.randint(0, n)
    j1 = np.random.randint(0, m)
    i2=a
    j2=b
    min = dist(i1,j1,a,b)
    if (img[i1][j1] == 255) and (tr[i1][j1] == 0):
        for i in range(n):
            for j in range(m):
                if (tr[i][j] == 200) and (dist(i1, j1, i, j) < min):
                    min = dist(i1, j1, i, j)
                    i2=i
                    j2=j
        # print(i1, j1)
        if (i2 == i1) and (j1>j2) :
            if (j2+1<m) and (img[i2][j2+1]==255) and (tr[i2][j2+1]==0):
                tr[i2][j2 + 1] = 200
                img1[i2][j2+1][0] = 255
                img1[i2][j2+1][1] = 25
                img1[i2][j2+1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2==c) and (j2+1==d):
                    break
        elif (i2 == i1) and (j1<j2) :
            if (j2>0) and (img[i2][j2-1]==255) and (tr[i2][j2-1]==0):
                tr[i2][j2 - 1] = 200
                img1[i2][j2-1][0] = 255
                img1[i2][j2-1][1] = 25
                img1[i2][j2-1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 == c) and (j2 - 1 == d):
                    break
        elif (j2 == j1) and (i1>i2) :
            if (i2 + 1 < n) and (img[i2+1][j2] == 255) and (tr[i2+1][j2] == 0):
                tr[i2 + 1][j2] = 200
                img1[i2+1][j2][0] = 255
                img1[i2+1][j2][1] = 25
                img1[i2+1][j2][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2+1 == c) and (j2== d):
                    break
        elif (j2 == j1) and (i1<i2) :
            if (i2>0) and (img[i2-1][j2]==255) and (tr[i2-1][j2]==0):
                tr[i2-1][j2] = 200
                img1[i2-1][j2][0] = 255
                img1[i2-1][j2][1] = 25
                img1[i2-1][j2][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 - 1 == c) and (j2 == d):
                    break
        elif (i2 < i1) and (j1>j2) :
            if (j2+1<m) and (i2 + 1 < n) and (img[i2+1][j2+1]==255) and (tr[i2+1][j2+1]==0):
                tr[i2+1][j2+1] = 200
                img1[i2+1][j2+1][0] = 255
                img1[i2+1][j2+1][1] = 25
                img1[i2+1][j2+1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 + 1 == c) and (j2+1 == d):
                    break
        elif (i2 > i1) and (j1>j2) :
            if (j2+1<m) and (i2>0) and (img[i2-1][j2+1]==255) and (tr[i2-1][j2+1]==0):
                tr[i2-1][j2+1] = 200
                img1[i2-1][j2+1][0] = 255
                img1[i2-1][j2+1][1] = 25
                img1[i2-1][j2+1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 - 1 == c) and (j2 + 1 == d):
                    break
        elif (i2 < i1) and (j1<j2) :
            if (j2>0) and (i2 + 1 < n) and (img[i2+1][j2-1]==255) and (tr[i2+1][j2-1]==0):
                tr[i2+1][j2-1] = 200
                img1[i2+1][j2-1][0] = 255
                img1[i2+1][j2-1][1] = 25
                img1[i2+1][j2-1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 + 1 == c) and (j2 - 1 == d):
                    break
        elif (i2 > i1) and (j1<j2) :
            if (j2>0) and (i2>0) and (img[i2-1][j2-1]==255) and (tr[i2-1][j2-1]==0):
                tr[i2-1][j2-1] = 200
                img1[i2-1][j2-1][0] = 255
                img1[i2-1][j2-1][1] = 25
                img1[i2-1][j2-1][2] = 25
                cv2.imshow('tree', img1.astype(np.uint8))
                cv2.waitKey(10)
                if (i2 - 1 == c) and (j2 - 1 == d):
                    break

path1 = np.full((n,m),0)
path1[a][b] = 1
k=1

def trac(k1):
    for i in range(n):
        for j in range(m):
            if path1[i][j]==k1 :
                if (i > 0) and (img[i - 1][j] == 255) and (tr[i - 1][j] == 200) and (path1[i-1][j]==0):
                    path1[i - 1][j] = k1+1
                if (j > 0) and (img[i][j-1] == 255) and (tr[i][j-1] == 200) and (path1[i][j-1]==0):
                    path1[i][j-1] = k1+1
                if (i + 1 < n) and (img[i + 1][j] == 255) and (tr[i + 1][j] == 200) and (path1[i+1][j]==0):
                    path1[i+1][j] = k1 + 1
                if (j + 1 < m) and (img[i][j + 1] == 255) and (tr[i][j + 1] == 200) and (path1[i][j+1]==0):
                    path1[i][j+1] = k1 + 1
                if (i + 1 < n) and (j + 1 < m) and (img[i + 1][j+1] == 255) and (tr[i + 1][j + 1] == 200) and (path1[i+1][j+1]==0):
                    path1[i + 1][j + 1] = k1+1
                if (i + 1 < n) and (j > 0) and (img[i + 1][j-1] == 255) and (tr[i + 1][j - 1] == 200) and (path1[i+1][j-1]==0):
                    path1[i + 1][j - 1] = k1+1
                if (j + 1 < m) and (i > 0) and (img[i - 1][j+1] == 255) and (tr[i - 1][j + 1] == 200) and (path1[i-1][j+1]==0):
                    path1[i - 1][j + 1] = k1+1
                if (i > 0) and (j > 0) and (img[i - 1][j-1] == 255) and (tr[i - 1][j - 1] == 200) and (path1[i-1][j-1]==0):
                    path1[i - 1][j - 1] = k1+1

while True:
    trac(k)
    k+=1
    if path1[c][d] > 1:
        break
p=path1[c][d]
img1[c][d][0] = 10
img1[c][d][1] = 10
img1[c][d][2] = 255
def retrac(c2,d2,p2):
    global c
    global d
    if (c2 > 0) and (path1[c2 - 1][d2] == p2 - 1):
        c = c2 - 1
        d = d2
        tr[c2 - 1][d2] = 255
        img1[c2-1][d2][0]=10
        img1[c2-1][d2][1]=10
        img1[c2-1][d2][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (d2 > 0) and (path1[c2][d2 - 1] == p2 - 1):
        c = c2
        d = d2 - 1
        tr[c2][d2 - 1] = 255
        img1[c2][d2-1][0]=10
        img1[c2][d2-1][1]=10
        img1[c2][d2-1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (d2 + 1 < m) and (path1[c2][d2 + 1] == p2 - 1):
        c = c2
        d = d2 + 1
        tr[c2][d2 + 1] = 255
        img1[c2][d2+1][0]=10
        img1[c2][d2+1][1]=10
        img1[c2][d2+1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (c2 + 1 < n) and (path1[c2 + 1][d2] == p2 - 1):
        c = c2 + 1
        d = d2
        tr[c2 + 1][d2] = 255
        img1[c2+1][d2][0]=10
        img1[c2+1][d2][1]=10
        img1[c2+1][d2][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (c2 + 1 < n) and (d2 + 1 < m) and (path1[c2 + 1][d2 + 1] == p2 - 1):
        c = c2 + 1
        d = d2 + 1
        tr[c2 + 1][d2 + 1] = 255
        img1[c2+1][d2+1][0]=10
        img1[c2+1][d2+1][1]=10
        img1[c2+1][d2+1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (c2 > 0) and (d2 + 1 < m) and (path1[c2 - 1][d2 + 1] == p2 - 1):
        c = c2 - 1
        d = d2 + 1
        tr[c2 - 1][d2 + 1] = 255
        img1[c2-1][d2+1][0]=10
        img1[c2-1][d2+1][1]=10
        img1[c2-1][d2+1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (d2 > 0) and (c2 + 1 < n) and (path1[c2 + 1][d2 - 1] == p2 - 1):
        c = c2 + 1
        d = d2 - 1
        tr[c2 + 1][d2 - 1] = 255
        img1[c2+1][d2-1][0]=10
        img1[c2+1][d2-1][1]=10
        img1[c2+1][d2-1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)
    elif (d2 > 0) and (c2 > 0) and (path1[c2 - 1][d2 - 1] == p2 - 1):
        c = c2 - 1
        d = d2 - 1
        tr[c2 - 1][d2 - 1] = 255
        img1[c2-1][d2-1][0]=10
        img1[c2-1][d2-1][1]=10
        img1[c2-1][d2-1][2]=255
        cv2.imshow('tree', img1.astype(np.uint8))
        cv2.waitKey(10)


while p>1:
    retrac(c,d,p)
    p=p-1
print("Distance = " , path1[c1][d1])
end = time.time()
print(end-begin)
cv2.waitKey(0)
cv2.destroyAllWindows()
